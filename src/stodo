#!/usr/bin/env bash

progname=$(basename $0)
stodopath=$(dirname $0)
initproc=main/initial-processing.rb
notifyproc=main/ongoing-processing.rb
mktmpl=main/stodo-template.rb
report=main/report.rb
edit=main/stodo-mgmt.rb
admin=main/stodo-admin.rb
stodo_envpath="$STODO_PATH"
specpath_expr='^# *spec-path:'


mainhelp() {
    gap="    "
    echo -e "Usage: $progname <command>\n\ncommands:"
    echo -e "  help [<x>]${gap}     show help (on topic <x>, if provided)"
    echo -e "  new|init ${gap}      look for and process new to-do items"
    echo -e "  notify ${gap}        send pending notifications to-do items"
    echo -e "  combined${gap}       combine notifications with processing of \c"
    echo -e "new items"
    echo -e "  report ${gap}        display a report of existing to-do items"
    echo -e "  del <h>...${gap}     delete targets with handles <h>, ..."
    echo -e "  clear_d <h>...${gap} clear descendants of targets with \c"
    echo -e "handle specs <h>, ..."
    echo -e "  stat <x> <h>...${gap}change status of handles <h>, ... to \c"
    echo -e "state-change <x>"
    echo -e "  temp [<type>]${gap}  output a to-do item template \c"
    echo -e "(for target type <type>)"
    echo -e "  backup ${gap}        back up data files"
}

indepth_help() {
  case "$1" in
    rep*) report_help ;;
    clear*) clear_d_help ;;
    temp*) template_help ;;
    sta*) state_help ;;
  esac
}

help() {
  if [ $# == 0 ]; then
    mainhelp
  else
    indepth_help $*
  fi
}

set_rubylib() {
  moredirs="facility error configuration notification specs data"
  moredirs="$moredirs coordination util"
  rubylib="RUBYLIB=$STEXEC_PATH/core"
  for d in $moredirs; do
    rubylib="$rubylib:$STEXEC_PATH/$d"
  done
  eval export $rubylib
}

checkpath() {
  for f in $*; do
    STEXEC_PATH=
    for p in $stodopath $stodo_envpath; do
      if [ -x "$p/$f" ]; then
        STEXEC_PATH=$p
      fi
    done
    if [ -z "$STEXEC_PATH" ]; then
      echo "Error: file $f not found"
      exit 11
    fi
  done
  if [ -z "$rubylib" ]; then
    set_rubylib
  fi
}

# If env. var. ST_RM_EXTRN (i.e., "stodo remove extraneous [files]") is
# not empty, remove (unconditionally - 'rm -f ...') the specified file ($1).
# If env. var. ST_VERBOSE is not empty, do not suppress any stderr output
# from the removal attempt and return the exit value of the 'rm' command;
# otherwise, suppress all output and return the default value (0).
# If env. var. ST_RM_EXTRN is empty or nonexistent, perform a null op -
# i.e., simply return with success status (0).
conditionally_remove_file() {
  local target=$1
  local result=0
  if [ "$ST_RM_EXTRN" ]; then
    if [ "$ST_VERBOSE" ]; then
      rm -f $target
      result=$?
    else
      rm -f $target 2>/dev/null
    fi
  fi
  return $result
}

run() {
  cmd=$1; shift
  $RUBY_EXEC $STEXEC_PATH/$cmd "$@"
  status=$?
  if [ $status -ne 0 ]; then
    echo "command failed [$RUBY_EXEC $STEXEC_PATH/$cmd $@]" >&2
    exit $status
  fi
}

process_new_items() {
  checkpath $initproc
  run $initproc
}

process_notifications() {
  checkpath $notifyproc
  run $notifyproc
}

do_combined_processing() {
  checkpath $initproc $notifyproc
  run $initproc
  sleep 1
  run $notifyproc
}

do_report() {
  checkpath $report
  modded_args=
  case $1 in
    -a*) shift; modded_args=$1:ignore; shift
      ;;
    -p*) shift; modded_args=$1:inprog; shift
      ;;
    -*) shift
      ;;
  esac
  run $report $modded_args $*
}

do_edit() {
  checkpath $edit
  run $edit $*
}

do_backup() {
  checkpath $admin
  run $admin backup $*
}

install_specfile() {
  file=$1
  specpath=$(awk "/$specpath_expr/"'{print $NF}' $file)
  if [ "$specpath" ]; then
    echo "Installing $file to $specpath" >&2
    mv $file $specpath || {
      status=$?
      echo "Error: Move of $file to $specpath failed." >&2
    }
  fi
  return $status
}

# Create the template contents.  If env. var. EDITOR is not empty, invoke
# $EDITOR to allow the user to edit the contents in a temporary file and
# "install" it by calling install_specfile on the file.  Otherwise, simply
# output the template contents to stdout.
# If env. var. ST_RM_EXTRN (standing for "stodo remove extraneous [files]")
# is not empty, ensure that any temporary files created by this procedure
# are removed.
make_template() {
  checkpath $mktmpl
  type=$1
  case $type in
    -*) type=task
      ;;
    *) shift
      ;;
  esac
  if [ -w . ]; then
    outfile=$(mktemp $type.XXXX)
    run $mktmpl $type "$@" >$outfile
    if [ "$EDITOR" ]; then
      if $EDITOR $outfile; then
        install_specfile $outfile
      fi
    else
      cat $outfile
    fi
    conditionally_remove_file $outfile
    exit $?
  else
    run $mktmpl "$@"
  fi
}

report_help() {
  local s='   '
  echo -e "Usage: $progname rep[ort] [<report-type> [<criteria>]]"
  echo -e "\nWhere <report-type> is one of:"
  echo -e "  handle $s     list only matching handles"
  echo -e "  short $s      short report - list only handles and titles"
  echo -e "  summary $s    summary report for the specified handles"
  echo -e "  complete $s   complete report for the specified handles"
  echo -e "  due $s        pending items with their \"due\" date"
  echo -e "  remind $s     upcoming (first) reminder"
  echo -e "  remindh $s    upcoming (first) reminder" \
    "(with handle instead of title)"
  echo -e "  remindall $s  all upcoming reminders"
  echo -e "  children $s   report of all child relationships"
  echo -e "Where <criteria> is either:"
  echo -e "  <type-spec>"
  echo -e "  <space-separated list of handles> - e.g., handle1 handle2 ..."
  echo -e "<type-spec> - one or more of the following, separated by '@':"
  echo -e "  pri:<n1>[,<n2>[,...]]  - only priorities <n1>, <n2>, ..."
  echo -e "  stat:<s1>[,<s2>[,...]] - only statuses <s1>, <s2>, ..."
  echo -e "  title:<regex>          - only items whose title matches <regex>"
  echo -e "  handle:<regex>         - only items whose handle matches <regex>"
  echo -e "  descr:<regex>          - only items whose description matches "\
    "<regex>"
  echo -e "\nNotes:"
  echo -e " - If <report-type> is not specified, list all target handles."
}

clear_d_help() {
  local s='   '
  echo -e "Usage: $progname clear_d[escendants] <hndlspec>..."
  echo -e "\nWhere <hndlspec> is:"
  echo -e "  <hnd1>[:<hnd2>[:...]] remove all descendants for <hnd1> except for"
  echo -e "                        those whose handles match <hnd2>, etc. -"
  echo -e "                        i.e., treat the specified handles \c"
  echo -e "(<hnd2>...)"
  echo -e "                        as exceptions that should not be removed."
}

template_help() {
  local s='     '
  echo -e "Usage: $progname temp [<type>] [options]"
  echo -e "Where <type> is one of:\c"
  echo -e " task, memo, appointment (or event), project"
  echo -e "(If <type> is not specified, assume 'task'.)"
  echo -e "\nOptions:"
  echo -e "  -t <title> $s     Use <title> as the Title"
  echo -e "  -h <handle> $s    Use <handle> as the Handle"
  echo -e "  -d <desc> $s      Use <desc> as the Description"
  echo -e "  -c <cat>... $s    Use <cat>... as the Category/Categories"
  echo -e "  -e <email> $s     Use <email> as the Email address"
  echo -e "  -ti <datetime>$s  Use <datetime> as the date&time"
  echo -e "  -ie <email> $s    Use <email> as the Initial Email address"
  echo -e "  -oe <email> $s    Use <email> as the Ongoing Email address"
  echo -e "  -p <handle> $s    Use <handle> to specify the Parent"
  echo -e "  -ci <id>... $s    Use <id>... as the Calendar Ids"
  echo -e "  -l <loc> $s       Use <loc> as the location (appointment only)"
  echo -e "  -du <dur> $s      Use <dur> as the duration (appointment only)"
  echo -e "  -pr <priority> $s Use <priority> as the priority"
}

state_help() {
  echo -e "Usage: $progname stat[us] <state-change> <handle>..."
  echo -e "  Where <state-change> is one of:\c"
  echo -e "  cancel, resume, finish, suspend"
  echo -e "  with the following possible state changes:\n"
  echo -e "   current state | state-change | new state"
  echo -e "  -------------------------------------------"
  echo -e "  'in-progress'  | cancel       | 'canceled'"
  echo -e "  'in-progress'  | suspend      | 'suspended'"
  echo -e "  'in-progress'  | finish       | 'completed'"
  echo -e "  'suspended'    | resume       | 'in-progress'"
  echo -e "  'suspended'    | cancel       | 'canceled'"
}

case $1 in
  new|init) process_new_items
    ;;
  noti*) process_notifications
    ;;
  comb*) do_combined_processing
    ;;
  rep*) shift; do_report $*
    ;;
  del*)
    shift;
    do_edit delete $*
    ;;
  clear_d*)
    shift;
    do_edit clear_descendants $*
    ;;
  sta*)
    shift;
    new_state=$1; shift
    do_edit state:$new_state $*
    ;;
  temp*) shift; make_template "$@"
    ;;
  back*) shift; do_backup $*
    ;;
  *) shift; help $*
    ;;
esac

exit $?
